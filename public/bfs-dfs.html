<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">

    <title>HoCo Hour of Code</title>

    <link rel="icon" href="logo.svg">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <link rel="stylesheet" href="fonts.css">
    <link rel="stylesheet" href="navbar.css">
    <link rel="stylesheet" href="formatting.css">
    <link rel="stylesheet" href="buttons.css">
    <link rel="stylesheet" href="hover.css">
    <link rel="stylesheet" href="article-styles.css">
    <link rel="stylesheet"
        href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/tomorrow-night-blue.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script type="text/javascript">
        function login_disabled() {
          alert('Login is disabled after the event.');
        }
    </script>
</head>

<body style="margin: 0">
    <div class="navbar-shadow full-width margin-0 padding-0">
        <div class="max-w-6xl block-center">
            <nav class="navbar">
                <div class="flex justify-between h-16">
                    <div class="flex justify-left items-center">
                        <a href="index.html">
                            <img src="logo.svg" alt="logo.svg" class="h-16">
                        </a>
                        <div style="width: 4rem"></div>
                        <div class="hvr-underline-reveal">
                            <a href="index.html" class="navbar-font color-grey margin-4 full-height">
                                <div class="navbar-tile">
                                    Home
                                </div>
                            </a>
                        </div>
                        <div style="width: 4rem"></div>
                        <div class="hvr-underline-reveal">
                            <a href="articles.html" class="navbar-font color-grey margin-4 full-height">
                                <div class="navbar-tile">
                                    Articles
                                </div>
                            </a>
                        </div>
                        <div style="width: 4rem"></div>
                        <div class="hvr-underline-reveal">
                            <a href="leaderboard.html" class="navbar-font color-grey margin-4 full-height">
                                <div class="navbar-tile">
                                    Leaderboard
                                </div>
                            </a>
                        </div>


                    </div>

                    <div class="flex justify-left items-center">
                        <div class="hvr-underline-reveal">
                            <a href="javascript:login_disabled()" class="navbar-font color-grey h-16 margin-4 login">
                                <div class="navbar-tile username">
                                    Login
                                </div>
                            </a>
                        </div>
                    </div>
                </div>
            </nav>
        </div>
    </div>

    <div class="relative pt-6 pb-32 full-width block-center padding-0" style="border: 0 solid white">
        <div class="max-w-2xl block-center">
            <div class="flex flex-column lm-4 rm-4">
                <!-- Title -->
                <div class="full-width article-title">BFS/DFS</div>

                <!-- Tags -->
                <div class="flex">
                    <div class="article-tag bg-hcpss-blue color-white rounded-md padding-1 rm-2">16pts</div>
                    <div class="article-tag bg-blue2 color-blue5 rounded-md padding-1 rm-2">Python</div>
                    <div class="article-tag bg-blue2 color-blue5 rounded-md padding-1 rm-2">Java</div>
                    <div class="article-tag bg-blue2 color-blue5 rounded-md padding-1 rm-2">C++</div>
                    <div class="article-tag bg-blue2 color-blue5 rounded-md padding-1 rm-2">Algorithms</div>
                    <div class="article-tag bg-blue2 color-blue5 rounded-md padding-1 rm-2">Data</div>
                </div>

                <!-- Subtitle -->
                <div class="article-subtitle color-grey mt-2">
                    Breadth-first search, depth-first search, and when to use them
                </div>

                <!-- Content -->
                
                <div class="article-content color-black mt-6 mb-3">
                    A brief review of graphs: A graph is a collection of <b>nodes</b> (the circles) connected by <b>edges</b> (the lines). <b>Traversing</b> a graph means traveling along these edges to visit other nodes.
                </div>

                <div class="article-content color-black mb-3">
                    How can we use graphs to solve problems? One such problem is searching for a node in a graph. For example, you could treat every cell in a maze as a node and connected cells as if there is an edge connecting those two nodes. The task of navigating the maze then boils down to: starting from a given node (the start of the maze) in a given graph (the maze), find the target node (the end of the maze).
                </div>

                <div class="article-content color-black mb-3">
                    <b>Breadth-first search</b> and <b>depth-first search</b> (BFS and DFS) are two different methods to accomplishing the task of finding a specific node in a graph. While both algorithms have the same goal — searching for a node — the main difference between these two methods is in how they search; while BFS prioritizes closer nodes (breadth), DFS will go as deep as possible into the graph first (depth).
                </div>

                <div class="article-content color-black mb-3">
                    Here is a visualization of BFS:
                </div>

                <img src="bfs-dfs-img-1.png" alt="bfs-dfs-img-1.png" class="mb-12 block-center full-width">

                <div class="article-content color-black mb-3">
                    In short, the strategy is to start with a node, mark down all adjacent nodes, then process the queued nodes one by one in the order that they were added to the queue. In the end, every node that could be reached from the starting node is processed, meaning as long as the node you are searching for is connected, you will find it.
                </div>

                <div class="article-content color-black mb-3">
                    Here’s what the implementation of BFS for the diagram above looks like. In this example, we use a 2D array to represent the edges; a <div class="mono-text">True</div> at <div class="mono-text">edges[i][j]</div> denotes that node <div class="mono-text">i</div> and node <div class="mono-text">j</div> have an edge connecting them.
                </div>

                <div class="tabs mb-12">
                    <input type="radio" name="tabs2" id="tab-4" checked="checked">
                    <label for="tab-4">Python</label>
                    <div class="tab">
                        Code:
                        <pre
                            class="margin-0 padding-0"><code class="python rounded-md code-text mt-2 padding-0.5"># set up nodes and edges
edges = [[False]*7 for i in range(7)]
edges[1][2] = True
edges[1][4] = True
edges[1][5] = True
edges[2][3] = True
edges[3][4] = True
edges[4][6] = True
edges[5][6] = True

# this tells the computer if we've visited this node before so we don't process it again
visited = [False] * 7

# target can be any node you want
target_node = 3

# set up our processing queue
queue = [1]

while len(queue) > 0:
    # get the next node in the queue and remove it from the queue
    current_node = queue[0]
    queue.pop(0)
    
    # if we've visited the node, we can skip it
    if visited[current_node]:
        continue
    
    print("Currently on node " + str(current_node))
    
    # identify when we've found the target node
    if current_node == target_node:
        print("Found target node!")
    
    # traverse the graph
    for i in range(7):
        if edges[current_node][i]:
            queue.append(i)
        
    # print the current queue
    print("Current queue: " + str(queue))
    print()
    
    # mark our current node as visited
    visited[current_node] = True
</code></pre>
                        <div class="h-8"></div>
                        Output:
                        <div class="output-text bg-code-blue rounded-md color-white padding-0.5 mt-2">
                            > Currently on node 1 <br>
> Current queue: [2, 4, 5]<br>
> <br>
> Currently on node 2<br>
> Current queue: [4, 5, 3]<br>
> <br>
> Currently on node 4<br>
> Current queue: [5, 3, 6]<br>
> <br>
> Currently on node 5<br>
> Current queue: [3, 6, 6]<br>
> <br>
> Currently on node 3<br>
> Found target node!<br>
> Current queue: [6, 6, 4]<br>
> <br>
> Currently on node 6<br>
> Current queue: [6, 4]
                        </div>
                    </div>

                    <input type="radio" name="tabs2" id="tab-5">
                    <label for="tab-5">Java</label>
                    <div class="tab">
                        Code:
                        <pre
                            class="margin-0 padding-0"><code class="java rounded-md code-text mt-2 padding-0.5">import java.util.*;
public class BFS {
    public static void main(String[] args){
        // set up nodes and edges
        boolean[][] edges = {{false, false, false, false, false, false, false}, {false, false, true, false, true, true, false}, {false, false, false, true, false, false, false}, {false, false, false, false, true, false, false}, {false, false, false, false, false, false, true}, {false, false, false, false, false, false, true}, {false, false, false, false, false, false, false}};
        
        // this tells the computer if we've visited this node before so we don't process it again
        boolean[] visited = new boolean[7];
        
        // target can be any node you want
        int target_node = 3;
        
        // set up our processing queue
        LinkedList&lt;Integer> queue = new LinkedList&lt;Integer>();
        queue.add(1);
        
        while(!queue.isEmpty()) {
            // get the next node in the queue and remove it from the queue
            int current_node = queue.remove();
            
            // if we've visited the node, we can skip it
            if(visited[current_node]) {
                continue;
            }
            
            System.out.println("Currently on node " + current_node);
            
            // identify when we've found the target node
            if(current_node == target_node) {
                System.out.println("Found target node!");
            }
            
            // traverse the graph
            for(int i = 0; i < 7; i++) {
                if(edges[current_node][i]) {
                    queue.add(i);
                }
            }
            
            // print the current queue
            System.out.print("Current queue: ");
            for(int x : queue) {
                System.out.print(x + " ");
            } 
            System.out.println();
            System.out.println();
            
            // mark our current node as visited
            visited[current_node] = true;
        }
    }
}
</code></pre>
                        <div class="h-8"></div>
                        Output:
                        <div class="output-text bg-code-blue rounded-md color-white padding-0.5 mt-2">
                            > Currently on node 1 <br>
> Current queue: 2 4 5<br>
> <br>
> Currently on node 2<br>
> Current queue: 4 5 3<br>
> <br>
> Currently on node 4<br>
> Current queue: 5 3 6<br>
> <br>
> Currently on node 5<br>
> Current queue: 3 6 6<br>
> <br>
> Currently on node 3<br>
> Found target node!<br>
> Current queue: 6 6 4<br>
> <br>
> Currently on node 6<br>
> Current queue: 6 4
                        </div>
                    </div>

                    <input type="radio" name="tabs2" id="tab-6">
                    <label for="tab-6">C++</label>
                    <div class="tab">
                        Code:
                        <pre
                            class="margin-0 padding-0"><code class="cpp rounded-md code-text mt-2 padding-0.5">#include &lt;bits/stdc++.h>

using namespace std;

// set up nodes and edges
bool edges[7][7] = {{false, false, false, false, false, false, false}, {false, false, true, false, true, true, false}, {false, false, false, true, false, false, false}, {false, false, false, false, true, false, false}, {false, false, false, false, false, false, true}, {false, false, false, false, false, false, true}, {false, false, false, false, false, false, false}};

// this tells the computer if we've visited this node before so we don't process it again
bool visited[7] = {};

// target can be any node you want
int target_node = 3;

// this function prints the queue
void print_queue(queue&lt;int> q) {
  while (!q.empty())
  {
    cout << q.front() << " ";
    q.pop();
  }
}

int main() {
    // set up our processing queue
    queue&lt;int> q;
    q.push(1);
    
    while(!q.empty()) {
        // get the next node in the queue and remove it from the queue
        int current_node = q.front();
        q.pop();
        
        // if we've visited the node, we can skip it
        if(visited[current_node]) {
            continue;
        }
        
        cout << "Currently on node " << current_node << "\n";
        
        // identify when we've found the target node
        if(current_node == target_node) {
            cout << "Found target node!\n";
        }
        
        // traverse the graph
        for(int i = 0; i < 7; i++) {
            if(edges[current_node][i]) {
                q.push(i);
            }
        }
        
        // print the current queue
        cout << "Current queue: ";
        print_queue(q);
        cout << "\n\n";
        
        // mark our current node as visited
        visited[current_node] = true;
    }

    return 0;
}
</code></pre>
                        <div class="h-8"></div>
                        Output:
                        <div class="output-text bg-code-blue rounded-md color-white padding-0.5 mt-2">
                            > Currently on node 1 <br>
> Current queue: 2 4 5<br>
> <br>
> Currently on node 2<br>
> Current queue: 4 5 3<br>
> <br>
> Currently on node 4<br>
> Current queue: 5 3 6<br>
> <br>
> Currently on node 5<br>
> Current queue: 3 6 6<br>
> <br>
> Currently on node 3<br>
> Found target node!<br>
> Current queue: 6 6 4<br>
> <br>
> Currently on node 6<br>
> Current queue: 6 4
                        </div>
                    </div>
                </div>

                <div class="article-content color-black mb-3">
                    You can play with the BFS code on Replit:
                </div>

                <div class="tabs mb-12">
                    <input type="radio" name="tabs1000" id="tab-1000" checked="checked">
                    <label for="tab-1000">Python</label>
                    <div class="tab">
                        <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@RHHSProgramming/bfs-dfs-python-1?lite=true"></iframe>
                    </div>

                    <input type="radio" name="tabs1000" id="tab-1001">
                    <label for="tab-1001">Java</label>
                    <div class="tab">
                        <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@RHHSProgramming/bfs-dfs-java-1?lite=true"></iframe>
                    </div>

                    <input type="radio" name="tabs1000" id="tab-1002">
                    <label for="tab-1002">C++</label>
                    <div class="tab">
                        <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@RHHSProgramming/bfs-dfs-cpp-1?lite=true"></iframe>
                    </div>
                </div>

                <div class="article-content-sectiontitle color-black mb-3">Depth-first search</div>

                <div class="article-content color-black mb-3">
                    How does BFS compare to DFS?
                </div>

                <img src="bfs-dfs-img-2.png" alt="bfs-dfs-img-2.png" class="mb-12 block-center full-width">

                <div class="article-content color-black mb-3">
                    As seen in the diagram above, DFS does not wait for a node to check its neighbors first. It immediately begins processing the first neighbor it finds, waiting until that node is fully processed before checking any other neighbors. Consequently, nodes that further away have a chance to be visited much faster.
                </div>

                <div class="article-content color-black mb-3">
                    Here’s what the implementation of DFS looks like. It uses the same method to store nodes and edges as the BFS implementation.
                </div>

                <div class="tabs mb-3">
                    <input type="radio" name="tabs3" id="tab-7" checked="checked">
                    <label for="tab-7">Python</label>
                    <div class="tab">
                        Code:
                        <pre
                            class="margin-0 padding-0"><code class="python rounded-md code-text mt-2 padding-0.5"># set up nodes and edges
edges = [[False]*7 for i in range(7)]
edges[1][2] = True
edges[1][4] = True
edges[1][5] = True
edges[2][3] = True
edges[3][4] = True
edges[4][6] = True
edges[5][6] = True

# this tells the computer if we've visited this node before so we don't process it again
visited = [False] * 7

# target can be any node you want
target_node = 3
    
def dfs(current_node):
    # if we've visited the node, we can skip it
    if visited[current_node]:
        return
    
    # mark our current node as visited
    visited[current_node] = True
    
    print("Currently on node " + str(current_node))
    
    # identify when we've found the target node
    if current_node == target_node:
        print("Found target node!")
    
    # traverse the graph
    for i in range(7):
        if edges[current_node][i]:
            dfs(i)

# call the function
dfs(1)
</code></pre>
                        <div class="h-8"></div>
                        Output:
                        <div class="output-text bg-code-blue rounded-md color-white padding-0.5 mt-2">
                            > Currently on node 1<br>
> Currently on node 2<br>
> Currently on node 3<br>
> Found target node!<br>
> Currently on node 4<br>
> Currently on node 6<br>
> Currently on node 5
                        </div>
                    </div>

                    <input type="radio" name="tabs3" id="tab-8">
                    <label for="tab-8">Java</label>
                    <div class="tab">
                        Code:
                        <pre
                            class="margin-0 padding-0"><code class="java rounded-md code-text mt-2 padding-0.5">import java.util.*;
public class DFS {
    public static void main(String[] args){
        // set up nodes and edges
        boolean[][] edges = {{false, false, false, false, false, false, false}, {false, false, true, false, true, true, false}, {false, false, false, true, false, false, false}, {false, false, false, false, true, false, false}, {false, false, false, false, false, false, true}, {false, false, false, false, false, false, true}, {false, false, false, false, false, false, false}};
        
        // this tells the computer if we've visited this node before so we don't process it again
        boolean[] visited = new boolean[7];
        
        // target can be any node you want
        int target_node = 3;
        
        dfs(1, edges, visited, target_node);
    }
    
    static void dfs(int current_node, boolean[][] edges, boolean[] visited, int target_node) {
        // if we've visited the node, we can skip it
        if(visited[current_node]) {
            return;
        }
        
        // mark our current node as visited
        visited[current_node] = true;
        
        System.out.println("Currently on node " + current_node);
        
        // identify when we've found the target node
        if(current_node == target_node) {
            System.out.println("Found target node!");
        }
        
        // traverse the graph
        for(int i = 0; i < 7; i++) {
            if(edges[current_node][i]) {
                dfs(i, edges, visited, target_node);
            }
        }
    }
}
</code></pre>
                        <div class="h-8"></div>
                        Output:
                        <div class="output-text bg-code-blue rounded-md color-white padding-0.5 mt-2">
                            > Currently on node 1<br>
> Currently on node 2<br>
> Currently on node 3<br>
> Found target node!<br>
> Currently on node 4<br>
> Currently on node 6<br>
> Currently on node 5
                        </div>
                    </div>

                    <input type="radio" name="tabs3" id="tab-9">
                    <label for="tab-9">C++</label>
                    <div class="tab">
                        Code:
                        <pre
                            class="margin-0 padding-0"><code class="cpp rounded-md code-text mt-2 padding-0.5">#include &lt;bits/stdc++.h>

using namespace std;

// set up nodes and edges
bool edges[7][7] = {{false, false, false, false, false, false, false}, {false, false, true, false, true, true, false}, {false, false, false, true, false, false, false}, {false, false, false, false, true, false, false}, {false, false, false, false, false, false, true}, {false, false, false, false, false, false, true}, {false, false, false, false, false, false, false}};

// this tells the computer if we've visited this node before so we don't process it again
bool visited[7] = {};

// target can be any node you want
int target_node = 3;

void dfs(int current_node) {
    // if we've visited the node, we can skip it
    if(visited[current_node]) {
        return;
    }
    
    // mark our current node as visited
    visited[current_node] = true;
    
    cout << "Currently on node " << current_node << "\n";
    
    // identify when we've found the target node
    if(current_node == target_node) {
        cout << "Found target node!\n";
    }
    
    // traverse the graph
    for(int i = 0; i < 7; i++) {
        if(edges[current_node][i]) {
            dfs(i);
        }
    }
}

int main() {
    dfs(1);

    return 0;
}
</code></pre>
                        <div class="h-8"></div>
                        Output:
                        <div class="output-text bg-code-blue rounded-md color-white padding-0.5 mt-2">
                            > Currently on node 1<br>
> Currently on node 2<br>
> Currently on node 3<br>
> Found target node!<br>
> Currently on node 4<br>
> Currently on node 6<br>
> Currently on node 5
                        </div>
                    </div>
                </div>

                <div class="full-width bg-blue1 padding-3 color-blue5 border-box lborder-blue3 mb-3">
                    Note: Both the BFS and DFS implementations are extremely inefficient (and non-scalable) ways of storing edges/nodes and traversing the graph, only used for demonstration purposes. Please Google more efficient implementations if you plan on using BFS or DFS.
                </div>

                <div class="article-content color-black mb-3">
                    When deciding between BFS vs. DFS, you need to consider where your target node is probably located. If it’s far away from the starting node (like in most mazes), DFS has a slight chance to find it early because it fully traverses every pathway before returning to the start. However, BFS is guaranteed to find it after processing most of the other nodes since it searches every node close to the starting node before moving on. In this case, DFS is the better choice. Conversely, if a node is located close to the starting node, BFS is guaranteed to find it very quickly, whereas DFS will keep searching very far away and only has a slight chance of finding the node as promptly as BFS. In this case, BFS is the better choice.
                </div>

                <div class="article-content color-black mb-3">
                    You can play with the DFS code on Replit:
                </div>

                <div class="tabs mb-12">
                    <input type="radio" name="tabs10000" id="tab-10000" checked="checked">
                    <label for="tab-10000">Python</label>
                    <div class="tab">
                        <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@RHHSProgramming/bfs-dfs-python-2?lite=true"></iframe>
                    </div>

                    <input type="radio" name="tabs10000" id="tab-10001">
                    <label for="tab-10001">Java</label>
                    <div class="tab">
                        <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@RHHSProgramming/bfs-dfs-java-2?lite=true"></iframe>
                    </div>

                    <input type="radio" name="tabs10000" id="tab-10002">
                    <label for="tab-10002">C++</label>
                    <div class="tab">
                        <iframe frameborder="0" width="100%" height="500px" src="https://replit.com/@RHHSProgramming/bfs-dfs-cpp-2?lite=true"></iframe>
                    </div>
                </div>
                
            </div>
        </div>
    </div>

    <div class="relative pt-6 pb-6 full-width bg-hcpss-offwhite block-center padding-0" style="border: 0 solid white">
        <div class="max-w-4xl block-center text-center">
          Join our <a href="https://discord.com/invite/tAKa8NapXD" style="display: inline">discord server</a> for updates, announcements, future event planning, to ask questions, or just for fun!<br>
            Copyright &copy;2021 Howard County Hour of Code
        </div>
      </div>
</body>